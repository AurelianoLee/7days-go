## 服务端与消息编码

## 客户端

## 服务注册

## 超时处理

需要客户端处理超时的地方：
- 与服务端建立连接，导致的超时
- 发送请求到服务端，导致的超时
- 等待服务端处理时，等待处理导致的超时（比如服务端已死，迟迟不响应
- 从服务端接收响应时，读报文导致的超时

需要服务端处理超时的地方：
- 读取客户端请求报文时，读报文导致的超时
- 发送响应报文时，写报文导致的超时
- 调用映射服务的方法时，处理报文导致的超时

## 支持 HTTP 协议

服务端支持 HTTP 协议：
1. 客户端向 RPC 服务器发送 CONNECT 请求
```
CONNECT 10.0.0.1.9999/_aurerpc_ HTTP/1.0
```
2. RPC 服务器返回 HTTP 200 状态码表示连接建立
3. 客户端使用创建好的连接发送 RPC 报文，先发送 Option，再发送 N 个请求报文，服务端处理 RPC 请求并响应

客户端支持 HTTP 协议：
1. HTTP 客户端发送 CONNECT 请求
2. 校验返回的请求，无误后使用 connection 创建客户端

## 负载均衡

假设有多个服务实例，每个实例提供相同的功能，为了提高整个系统的吞吐量，每个实例部署在不同的机器上。客户端可以选择任意一个实例进行调用，获取想要的结果。

负载均衡的策略：
1. 随机选择策略 - 从服务列表中随机选择一个
2. 轮询算法(Round Robin) - 依次调度不同的服务器，每次调度执行 i = (i+1) mod n
3. 加权轮询(Weight Round Robin) - 在轮询算法的基础上，为每个服务实例设置一个权重，高性能的机器赋予更高的权重，也可以根据服务实例的当前负载情况做动态调整，例如考虑最近5分钟部署服务器的CPU，内存消耗情况。
4. 哈希/一致性哈希。

负载均衡的前提是有多个服务实例，需要服务发现模块。

## 服务发现与注册中心

注册中心的好处：客户端和服务端解耦，客户端不需要知道服务端的地址，只需要知道注册中心地址即可。
1. 服务端启动后，向注册中心发送注册消息，注册中心得知该服务已经启动，处于可用状态。一般来说，服务端还需要定期向注册中心发送心跳，证明自己还活着。
2. 客户端向注册中心发送请求，注册中心返回哪些服务可用，将可用的服务列表返回给客户端。
3. 客户端根据注册中心得到的服务列表，选择一个服务，向该服务发起请求。

如果没有注册中心，客户端需要硬编码服务端的地址，而且没有机制保证服务端是否处于可用状态。当然注册中心的功能还有很多，比如配置的动态同步、通知机制等。
比较常用的注册中心有：`etcd`、`zookeeper`、`consul`等。

注册中心需要满足以下条件：
1. 实现心跳检测，设置默认超时时间，超过该时间则认为服务已死，标记服务为不可用。
2. 可以注册/添加服务实例，如果服务实例已存在，则更新服务实例信息。
3. 返回可用的服务列表。
4. 定时更新服务列表，删除过期的服务实例。这个可以集成到条件3中。

为了实现上的简单，RegistryCenter 采用HTTP协议提供服务，所有有用的信息都放在 HTTP Header 中。
- Get: 返回所有可用的服务列表，通过自定义字段 `X-Aurerpc-Servers` 承载。
- Post: 添加服务实例或发送心跳，通过自定义字段 `X-Aurerpc-Server` 承载。
